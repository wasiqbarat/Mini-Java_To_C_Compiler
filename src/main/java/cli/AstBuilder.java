package cli;

import main.*;
import ast.*;
import ast.expr.*;
import ast.stmt.*;
import org.antlr.v4.runtime.tree.ParseTree;

import java.util.ArrayList;
import java.util.List;

/**
 * Very small visitor that converts the Antlr parse-tree generated by MiniJava.g4
 * into the hand-written AST classes under the {@code ast} package.
 * <p>
 * It only covers the essential constructs for the first milestones; you can
 * extend it incrementally when new grammar paths are needed.
 */
public class AstBuilder extends MiniJavaBaseVisitor<Object> {

    /* Entry ------------------------------------------------------------ */
    public Program build(MiniJavaParser.ProgramContext ctx) {
        return (Program) visit(ctx);
    }

    /* Helper: convert list of parse-tree children with the visitor */
    private <T> List<T> visitAll(List<? extends ParseTree> children, Class<T> cls) {
        List<T> out = new ArrayList<>(children.size());
        for (ParseTree c : children) out.add(cls.cast(visit(c)));
        return out;
    }

    /* program â†’ mainClass classDecl* */
    @Override public Program visitProgram(MiniJavaParser.ProgramContext ctx) {
        MainClass main = (MainClass) visit(ctx.mainClass());
        List<ClassDecl> classes = visitAll(ctx.classDeclaration(), ClassDecl.class);
        return new Program(main, classes);
    }

    /* mainClass rule */
    @Override public MainClass visitMainClass(MiniJavaParser.MainClassContext ctx) {
        String className = ctx.Identifier(0).getText();
        String argName   = ctx.Identifier(1).getText();
        List<VarDecl> locals = visitAll(ctx.varDeclaration(), VarDecl.class);
        List<Statement> stmts = visitAll(ctx.statement(), Statement.class);
        return new MainClass(className, argName, locals, stmts);
    }

    /* classDeclaration */
    @Override public ClassDecl visitClassDeclaration(MiniJavaParser.ClassDeclarationContext ctx) {
        String name = ctx.Identifier(0).getText();
        String superName = ctx.EXTENDS() != null ? ctx.Identifier(1).getText() : null;
        List<VarDecl> fields = visitAll(ctx.varDeclaration(), VarDecl.class);
        List<MethodDecl> methods = visitAll(ctx.methodDeclaration(), MethodDecl.class);
        return new ClassDecl(name, superName, fields, methods);
    }

    /* varDeclaration */
    @Override public VarDecl visitVarDeclaration(MiniJavaParser.VarDeclarationContext ctx) {
        Type t = (Type) visit(ctx.type());
        String name = ctx.Identifier().getText();
        return new VarDecl(t, name);
    }

    /* methodDeclaration */
    @Override public MethodDecl visitMethodDeclaration(MiniJavaParser.MethodDeclarationContext ctx) {
        Type returnType = (Type) visit(ctx.type());
        String name = ctx.Identifier().getText();

        // Manually build the parameter list from the formalParameters context
        List<VarDecl> params = new ArrayList<>();
        if (ctx.formalParameters() != null) {
            MiniJavaParser.FormalParametersContext paramsCtx = ctx.formalParameters();
            for (int i = 0; i < paramsCtx.type().size(); i++) {
                Type paramType = (Type) visit(paramsCtx.type(i));
                String paramName = paramsCtx.Identifier(i).getText();
                params.add(new VarDecl(paramType, paramName));
            }
        }

        List<VarDecl> locals = visitAll(ctx.varDeclaration(), VarDecl.class);
        List<Statement> body = visitAll(ctx.statement(), Statement.class);
        Expression retExpr = (Expression) visit(ctx.expression());

        return new MethodDecl(returnType, name, params, locals, body, retExpr);
    }

    /* type */
    @Override public Type visitType(MiniJavaParser.TypeContext ctx) {
        if (ctx.INT() != null && ctx.LBRACK() != null) return Type.INT_ARR;
        if (ctx.INT() != null) return Type.INT;
        if (ctx.BOOLEAN() != null) return Type.BOOLEAN;
        // otherwise it is class identifier
        return new Type(ctx.Identifier().getText(), false);
    }

    /* ------------------------- statements --------------------------- */
    @Override public Statement visitBlockStmt(MiniJavaParser.BlockStmtContext ctx) {
        List<Statement> stmts = visitAll(ctx.statement(), Statement.class);
        return new BlockStmt(stmts);
    }

    @Override public Statement visitIfStmt(MiniJavaParser.IfStmtContext ctx) {
        Expression cond = (Expression) visit(ctx.expression());
        Statement thenB = (Statement) visit(ctx.statement(0));
        Statement elseB = (Statement) visit(ctx.statement(1));
        return new IfStmt(cond, thenB, elseB);
    }

    @Override public Statement visitWhileStmt(MiniJavaParser.WhileStmtContext ctx) {
        Expression cond = (Expression) visit(ctx.expression());
        Statement body = (Statement) visit(ctx.statement());
        return new WhileStmt(cond, body);
    }

    @Override public Statement visitDoWhileStmt(MiniJavaParser.DoWhileStmtContext ctx) {
        Statement body = (Statement) visit(ctx.statement());
        Expression cond = (Expression) visit(ctx.expression());
        return new DoWhileStmt(body, cond);
    }

    @Override public Statement visitPrintStmt(MiniJavaParser.PrintStmtContext ctx) {
        Expression arg = (Expression) visit(ctx.expression());
        return new PrintStmt(arg);
    }

    @Override public Statement visitBreakStmt(MiniJavaParser.BreakStmtContext ctx) {
        return new BreakStmt();
    }

    @Override public Statement visitContinueStmt(MiniJavaParser.ContinueStmtContext ctx) {
        return new ContinueStmt();
    }

    @Override public Statement visitAssignStmt(MiniJavaParser.AssignStmtContext ctx) {
        String name = ctx.Identifier().getText();
        Expression val = (Expression) visit(ctx.expression());
        return new AssignStmt(name, val);
    }

    /* for-loop desugaring */
    @Override public Statement visitForStmt(MiniJavaParser.ForStmtContext ctx) {
        // The init and update parts of a for-loop are lists of expressions.
        // The grammar nests them under forExprList, so we need to go one level deeper.
        List<Expression> init   = ctx.forInit()   == null ? List.of() : visitAll(ctx.forInit().forExprList().expression(), Expression.class);
        Expression cond         = ctx.forCondition() == null ? null : (Expression) visit(ctx.forCondition().expression());
        List<Expression> update = ctx.forUpdate() == null ? List.of() : visitAll(ctx.forUpdate().forExprList().expression(), Expression.class);
        Statement body = (Statement) visit(ctx.statement());
        return new ForStmt(init, cond, update, body);
    }

    /* ------------------------- expressions -------------------------- */
    @Override public Expression visitPrimaryExpr(MiniJavaParser.PrimaryExprContext ctx) {
        return (Expression) visit(ctx.primary());
    }

    @Override public Expression visitPrimary(MiniJavaParser.PrimaryContext ctx) {
        if (ctx.IntegerLiteral() != null) return new IntLiteral(Integer.parseInt(ctx.IntegerLiteral().getText()));
        if (ctx.TRUE() != null)  return new BooleanLiteral(true);
        if (ctx.FALSE() != null) return new BooleanLiteral(false);
        if (ctx.Identifier() != null) return new VarExpr(ctx.Identifier().getText());

        // Fallback for unimplemented primaries (this, new, etc.)
        return new VarExpr("<unsupported-primary>");
    }

    @Override public Expression visitAddSubExpr(MiniJavaParser.AddSubExprContext ctx) {
        Expression l = (Expression) visit(ctx.expression(0));
        Expression r = (Expression) visit(ctx.expression(1));
        BinaryOp op = ctx.bop.getText().equals("+") ? BinaryOp.ADD : BinaryOp.SUB;
        return new BinaryExpr(l, op, r);
    }

    @Override public Expression visitMulDivExpr(MiniJavaParser.MulDivExprContext ctx) {
        Expression l = (Expression) visit(ctx.expression(0));
        Expression r = (Expression) visit(ctx.expression(1));
        String sym = ctx.bop.getText();
        BinaryOp op = switch (sym) {
            case "*" -> BinaryOp.MUL;
            case "/" -> BinaryOp.DIV;
            default   -> BinaryOp.MOD;
        };
        return new BinaryExpr(l, op, r);
    }

    @Override public Expression visitRelExpr(MiniJavaParser.RelExprContext ctx) {
        Expression l = (Expression) visit(ctx.expression(0));
        Expression r = (Expression) visit(ctx.expression(1));
        BinaryOp op = switch (ctx.bop.getText()) {
            case "<"  -> BinaryOp.LT;
            case "<=" -> BinaryOp.LTE;
            case ">"  -> BinaryOp.GT;
            case ">=" -> BinaryOp.GTE;
            case "==" -> BinaryOp.EQ;
            default    -> BinaryOp.NEQ;
        };
        return new BinaryExpr(l, op, r);
    }

    @Override public Expression visitAndExpr(MiniJavaParser.AndExprContext ctx) {
        Expression l = (Expression) visit(ctx.expression(0));
        Expression r = (Expression) visit(ctx.expression(1));
        return new BinaryExpr(l, BinaryOp.AND, r);
    }

    @Override public Expression visitOrExpr(MiniJavaParser.OrExprContext ctx) {
        Expression l = (Expression) visit(ctx.expression(0));
        Expression r = (Expression) visit(ctx.expression(1));
        return new BinaryExpr(l, BinaryOp.OR, r);
    }

    /* Default fall-through */
    @Override protected Object defaultResult() { return null; }
}
